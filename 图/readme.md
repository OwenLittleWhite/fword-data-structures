# 图

图表示多对多的关系
包含
- 一组顶点：通常用 V (Vertex) 表示顶点集合
- 一组边：通常用 E (Edge) 表示边的集合
- 边是顶点对：(v, w) 表示无向边，有向边 < v, w> 表示从v指向w的边（单行线）
- 不考虑重边和自回路

抽象数据类型定义：

类型名称：图（Graph）

数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成。

操作集：建立图、将v顶点插入图等...

## 常见图的术语

无向图、有向图、网络（带权重）

## 表示图

### 邻接矩阵

使用邻接矩阵G[N][N] ——N个顶点从0到N-1编号

G[i][j] = 1 则表示 <vi, vj> 是G中的边

对于无向图的存储可以省一半的空间

用一个长度为N(N+1)/2的1维数组A存储 {G00,G10,G11,……,Gn-1 0,…,Gn-1 n-1}， 则Gij在A中对应的下标是： ( i*(i+1)/2 + j ) Gij的值可以表示权重

- 直观、简单、好理解
- 方便检查任意一对顶点间是否存在边
- 方便找任一顶点的所有“邻接点”（有边直接相连的顶点）
- 方便计算任一顶点的“度”（从该点发出的边数为“出
度”，指向该点的边数为“入度”）
    - 无向图：对应行（或列）非0元素的个数
    - 有向图：对应行非0元素的个数是“出度”；对应列非0元素的
个数是“入度”

### 邻接表

使用邻接表：G[N]为指针数组，对应矩阵每行一个链表，
只存非0元素

- [x] 方便找任一顶点的所有“邻接点”
- [x] 节约稀疏图的空间 需要N个头指针 + 2E个结点（每个结点至少2个域）
- [x] 方便计算任一顶点的“度”？
    - 对无向图：是的
    - 对有向图：只能计算“出度”；需要构造“逆邻接表”（存指向自
的边）来方便计算“入度”
- [x] 方便检查任意一对顶点间是否存在边？ No

## 图的遍历

### 深度优先搜索 DFS

类似于树的先序遍历

递归调用DFS

```JS
function DFS (V) {
    visited[V] = true
    for (V 的每个邻接点 W) {
        if (!visited[W]) {
            DFS(W)
        }
    }
}
```
若有N个结点，E条边，时间复杂度：

使用邻接表表示：O(N+E)

使用邻接矩阵表示：O(N^2)

### 广度优先搜索 BFS

类似于树的层序遍历

将一个顶点入队，然后出队将其邻接结点入队

```JS
function BFS(V) {
    visited[V] = true
    EnQueue(V, Q)
    while(!isEmpty(Q)) {
        V = DeQueue(Q)
        for (V 的每个邻接结点 W) {
            if (!visited[W]) {
                visited[W] = true
                Enqueue(W, Q)
            }
        }
    }

}
```

时间复杂度与DFS一致

## 图的连通

- 连通：如果从V到W存在一条（无向）路径，则称
V和W是连通的
- 路径：V到W的路径是一系列顶点{V, v1, v2, …, 
vn, W}的集合，其中任一对相邻的顶点间都有图
中的边。路径的长度是路径中的边数（如果带
权，则是所有边的权重和）。如果V到W之间的所
有顶点都不同，则称简单路径
- 回路：起点等于终点的路径
- 连通图：图中任意两顶点均连通

连通分量： 无向图的极大连通子图
- 极大顶点数：再加1个顶点就不连通了
- 极大边数：包含子图中所有顶点相连的所有边

- 强连通：有向图中顶点V和W之间存在双径，则称V和W是强连通的
- 强连通图：有向图中任意两顶点均强连通
- 强连通分量：有向图的极大强连通子图

图不连通的遍历

将每个结点遍历，没访问过则执行BFS或者DFS

```JS
function ListComponents (Graph G) {
    for (V in G) {
        if (!visited[V]) {
            DFS(V) // or BFS(V)
        }
    }
}
```
