# 树

一种层次关系称作树，家谱、组织架构、图书信息等

## 查找

根据某个给定关键字K ，从集合R中找出关键字与K相同的记录

### 静态查找

集合中记录是固定的，例如字典

方法一： 顺序查找，挨个遍历

方法二： 二分查找，数据存放要求是有序的

二分查找算法的实现

```JS
/**
 * 二分查找
 * @param {Number} element 待查找的元素
 * @param {Array<Number>} sortArr 要查找的有序数组，从小到大排序
 * @returns {Number} 返回该元素在数组中的下标
 */
function binarySearch(element, sortArr) {
  // 定义左右两个下标
  let left = 0;
  let right = sortArr.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2); // 中间位置
    let midValue = sortArr[mid];
    if (midValue > element) {
      right = mid - 1;
    } else if (midValue < element) {
      left = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
}
```

二分查找的时间复杂度为O(logN)

练习：手绘十一个元素的二分查找判定树

---

## 树的特点

1. 子树是不相交的
2. 除了根结点外，每个结点有且仅有一个父结点；  
3. 一棵N个结点的树有N-1条边。

### 树的表示

使用儿子-兄弟表示法，一个元素有两个指针域，一个指向儿子，一个指向兄弟。

n个节点总共2n个指针域

这种表示法就将普通树转化为了二叉树

二叉树即结点的度为2的树。

---

## 二叉树

### 特殊的二叉树：

1. 斜二叉树，所有结点只有左子树或者右子树。
2. 完美二叉树，满二叉树
3. 完全二叉树，对结点从上到下从左到右编号，第i个结点与满二叉树的第i个结点位置相同

### 二叉树的特性：

1. 一个二叉树第i层的最大结点树为，2^(i-1), i>=1
2. 深度为k的二叉树有最大的结点总数为2^k - 1, k>=1
3. 对任何的非空二叉树T，n0表示叶节点的个数，n1表示度为1的结点的个数，n2表示度为2的非叶结点的个数，则n0=n2+1。 推导 n0 + n1 + n2 - 1 = 0 * n0 + 1 * n1 + 2 * n2

二叉树的存储结构：

1. 顺序存储结构

完全二叉树从上到下从左到右依次编号，从1开始编号

n个结点父子关系

非根结点的 i （i>1）,的父结点为i/2取整
左儿子2i，右儿子2i+1

一般的二叉树采用这种表示的话，会造成大量空间的浪费。

2. 链表存储

一个结点有三个属性，左儿子的指针，右儿子的指针，和值

### 二叉树的遍历

1. 先序遍历
   1. 先访问根结点
   2. 先序遍历左子树
   3. 先序遍历右子树

2. 中序遍历
   1. 中序遍历左子树
   2. 访问根节点
   3. 中序遍历右子树

3. 后序遍历
   1. 后序遍历左子树
   2. 后序遍历右子树
   3. 访问根节点

先序、中序、后序遍历访问结点的路径是一样的，只不过是访问结点的时机不同，每个结点访问了三次

使用递归很容易实现。也可以采用堆栈的形式

提示： 画出遍历时走过的路径

4. 层序遍历

主要思想在于访问完一个结点之后要将其左右儿子保存下来

使用队列实现：从根结点开始，入队，然后从队列中结点出队，访问此结点，然后将其左右儿子入队

队列为空时循环结束。

练习：

有中序遍历和任意一种其他遍历能够唯一确认一个二叉树。

### 树的同构

两棵树T1和T2，如果T1的左右儿子经过交换变成了T2则两棵树是同构的。

可以使用结构数组来存储树

---

## 二叉搜索树

二叉搜索树（二叉查找树、二叉排序树）：一棵二叉树，可以为空；如果不为空，满足以下性质：

1. 非空左子树的所有键值小于其根结点的键值。
2. 非空右子树的所有键值大于其根结点的键值。
3. 左、右子树都是二叉搜索树。

### 二叉搜索树的几个特别函数

1. find(x, tree) 在树中查找某个元素
2. findMin(tree) 查找树中最小的元素
3. findMax(tree) 查找树中最大的元素
4. insert(x, tree) 树中插入元素
5. delete(x, tree) 树中删除元素

这几个函数的[JavaScript实现](https://github.com/OwenLittleWhite/fword-data-structures/blob/master/src/tree/BinaryTree.js)

---

## 平衡二叉树

搜索树不同的结点插入顺序将导致树不同的**深度**，以及平均查找长度**ASL**。

### 什么是平衡二叉树

“平衡因子（Balance Factor，简称BF）: BF(T) = hL-hR，
其中hL和hR分别为T的左、右子树的高度。

平衡二叉树（Balanced Binary Tree）（AVL树）
空树，或者
任一结点左、右子树高度差的绝对值不超过1，即|BF(T) |≤ 1

给定结点数为 n的AVL树的
最大高度为O(log2n)！

推导参考斐波那契序列

平衡二叉树，也是二叉搜索树，所以其调整时要保证左子树的值小于右子树的值

结点插入时那个结点的平衡因子的绝对值等于2了，此结点即是*发现者*也是*被破坏者*，插入的结点称之为*麻烦结点*，麻烦结点在发现者的右子树的右边则称为RR插入，需要RR旋转。同理另外三种插入为RL插入、LL插入、LR插入

---

练习：

两个长度相等的序列按顺序插入到一个二叉搜索树判断组成的树是否相等。

比如，arr1 = [3, 2, 1, 4] arr2 = [3, 1, 2, 4] arr3 = [3, 4, 1, 2]

```
   3            3         3
  / \          / \       / \
 2   4        1   4     1   4
/              \         \     
1               2         2
```

arr1 和 arr2 两者组成的树不一样， arr2 和 arr3 两者组成的树是一样的。

解题思路：

1. 构建两个二叉搜索树，然后递归的判断左子树是否一样，右子树是否一样，根结点是否一样
2. 不构建树，取第一个值，就是根结点，然后找出所有比根结点小的就是左子树，比根结点大的就是右子树，然后递归判断左右子树是否相等。
3. 构建一个树，另一个每个元素在这个树中查找，看走过的路径是否都是走过的。

## 堆

优先队列（Priority Queue）：特殊的“队列”，取出元素的顺序是
依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。

用完全二叉树表示，最大堆、最小堆

每个结点的元素值不小于其子结点的元素值

## 哈夫曼树

带权路径最小的二叉树，每次把权值最小的两个二叉树合并

## 并查集
